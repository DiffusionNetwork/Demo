# -*- coding: utf-8 -*-
from PyQt5.QtGui import QTextCursor
# Form implementation generated from reading ui file 'system_main_window.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtWidgets import *
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QTextCursor

import sys
import os
import numpy as np
import datetime
import pandas as pd
from sklearn.cluster import KMeans
import math
import copy
from concurrent.futures import ThreadPoolExecutor, wait
import random
import time
from numpy.linalg import norm

from dom_sets import get_homop_sim_matrix, get_cosine_sim_matrix, get_man_sim_matrix, get_eu_sim_matrix
from LMDN import *
from PIND_orig_utils import *
from LIDO_utils import *


class Ui_MainWindow(object):

    def __init__(self):

        self.file_path = ""
        self.lidu_type = "node"
        self.aspect_type = "one"
        self.data_type = "complete"
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(657, 434)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.groupBox_lidu = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_lidu.setGeometry(QtCore.QRect(40, 70, 161, 101))
        self.groupBox_lidu.setTitle("")
        self.groupBox_lidu.setObjectName("groupBox_lidu")
        self.layoutWidget = QtWidgets.QWidget(self.groupBox_lidu)
        self.layoutWidget.setGeometry(QtCore.QRect(40, 0, 81, 101))
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.radioButton_node_lidu = QtWidgets.QRadioButton(self.layoutWidget)
        self.radioButton_node_lidu.setObjectName("radioButton_node_lidu")
        self.verticalLayout.addWidget(self.radioButton_node_lidu)
        self.radioButton_group_lidu = QtWidgets.QRadioButton(self.layoutWidget)
        self.radioButton_group_lidu.setObjectName("radioButton_group_lidu")
        self.verticalLayout.addWidget(self.radioButton_group_lidu)
        self.pushButton_begin = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_begin.setGeometry(QtCore.QRect(270, 310, 111, 31))
        self.pushButton_begin.setObjectName("pushButton_begin")
        self.groupBox_aspect = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_aspect.setGeometry(QtCore.QRect(240, 70, 161, 101))
        self.groupBox_aspect.setTitle("")
        self.groupBox_aspect.setObjectName("groupBox_aspect")
        self.layoutWidget1 = QtWidgets.QWidget(self.groupBox_aspect)
        self.layoutWidget1.setGeometry(QtCore.QRect(30, 0, 106, 101))
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget1)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.radioButton_one_aspect = QtWidgets.QRadioButton(self.layoutWidget1)
        self.radioButton_one_aspect.setObjectName("radioButton_one_aspect")
        self.verticalLayout_2.addWidget(self.radioButton_one_aspect)
        self.radioButton_multi_aspect = QtWidgets.QRadioButton(self.layoutWidget1)
        self.radioButton_multi_aspect.setObjectName("radioButton_multi_aspect")
        self.verticalLayout_2.addWidget(self.radioButton_multi_aspect)
        self.groupBox_data = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_data.setGeometry(QtCore.QRect(450, 70, 171, 101))
        self.groupBox_data.setTitle("")
        self.groupBox_data.setObjectName("groupBox_data")
        self.layoutWidget2 = QtWidgets.QWidget(self.groupBox_data)
        self.layoutWidget2.setGeometry(QtCore.QRect(30, 0, 106, 101))
        self.layoutWidget2.setObjectName("layoutWidget2")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.layoutWidget2)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.radioButton_complete_data = QtWidgets.QRadioButton(self.layoutWidget2)
        self.radioButton_complete_data.setObjectName("radioButton_complete_data")
        self.verticalLayout_3.addWidget(self.radioButton_complete_data)
        self.radioButton_noise_data = QtWidgets.QRadioButton(self.layoutWidget2)
        self.radioButton_noise_data.setObjectName("radioButton_noise_data")
        self.verticalLayout_3.addWidget(self.radioButton_noise_data)
        self.radioButton_incomplete_data = QtWidgets.QRadioButton(self.layoutWidget2)
        self.radioButton_incomplete_data.setObjectName("radioButton_incomplete_data")
        self.verticalLayout_3.addWidget(self.radioButton_incomplete_data)
        self.lineEdit_file_address = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_file_address.setGeometry(QtCore.QRect(70, 200, 431, 21))
        self.lineEdit_file_address.setObjectName("lineEdit_file_address")
        self.toolButton_select_file = QtWidgets.QToolButton(self.centralwidget)
        self.toolButton_select_file.setGeometry(QtCore.QRect(510, 200, 91, 21))
        self.toolButton_select_file.setObjectName("toolButton_select_file")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(250, 0, 151, 41))
        font = QtGui.QFont()
        font.setPointSize(24)
        self.label.setFont(font)
        self.label.setObjectName("label")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 657, 24))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.radioButton_node_lidu.setChecked(True)  # 默认点击节点粒度选项
        self.radioButton_one_aspect.setChecked(True)  # 默认点击单模态选项
        self.radioButton_complete_data.setChecked(True)  # 默认点击完整数据选项


        # UI初始化完成，开始程序逻辑
        # 绑定signal与slot函数
        self.pushButton_begin.clicked.connect(self.pushButton_begin_event)
        self.radioButton_node_lidu.clicked.connect(self.node_lidu_clicked_event)
        self.radioButton_group_lidu.clicked.connect(self.group_lidu_clicked_event)
        self.radioButton_one_aspect.clicked.connect(self.one_aspect_clicked_event)
        self.radioButton_multi_aspect.clicked.connect(self.multi_aspect_clicked_event)
        self.radioButton_complete_data.clicked.connect(self.complete_data_clicked_event)
        self.radioButton_noise_data.clicked.connect(self.noise_data_clicked_event)
        self.radioButton_incomplete_data.clicked.connect(self.incomplete_data_clicked_event)
        self.toolButton_select_file.clicked.connect(self.get_file_path)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "传播网络重构"))
        self.radioButton_node_lidu.setText(_translate("MainWindow", "节点粒度"))
        self.radioButton_group_lidu.setText(_translate("MainWindow", "团体粒度"))
        self.pushButton_begin.setText(_translate("MainWindow", "开始"))
        self.radioButton_one_aspect.setText(_translate("MainWindow", "单质传播网络"))
        self.radioButton_multi_aspect.setText(_translate("MainWindow", "异质传播网络"))
        self.radioButton_complete_data.setText(_translate("MainWindow", "完整感染数据"))
        self.radioButton_noise_data.setText(_translate("MainWindow", "噪音感染数据"))
        self.radioButton_incomplete_data.setText(_translate("MainWindow", "缺失感染数据"))
        self.toolButton_select_file.setText(_translate("MainWindow", "上传历史感染数据"))
        self.label.setText(_translate("MainWindow", "传播网络重构"))

    def pushButton_begin_event(self, event):
        # 提交按钮被点击,首先检查提交数据类型是否符合选择类型，再开始推图

        # msgBox = QMessageBox()
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setText("传播网络推断结果如下")
        # msgBox.setWindowTitle("传播网络推断结构")
        # msgBox.setStandardButtons(QMessageBox.Ok)

        # 首先从输入框获取文件路径
        self.file_path = self.lineEdit_file_address.text()
        # 检查文件路径的合法性
        if not os.path.exists(self.file_path):
            QMessageBox.warning(None, "警告", "输入文件不存在", QMessageBox.Ok)

        # 根据文件路径读取数据
        record_data = self.read_records_and_graph(self.file_path)
        # 判断推断类型并开始推断
        if self.lidu_type == "group":
            # 团体粒度推断
            result = self.DPM(record_data)
            mode = 3
        elif self.aspect_type == "multi":
            # 多模态推断
            result = self.Multi_Aspect(record_data)
            mode = 4

        elif self.data_type == "complete":
            # 不是团体和多模态那就是节点完整数据推断
            result = self.IMI_prune(record_data)
            mode = 0
        elif self.data_type == "noise":
            # 节点噪声数据推断
            result = self.PIND(record_data)
            mode = 2
        else:
            # 节点缺失数据推断
            result = self.LIDO(record_data)
            mode = 1

        result_dialog = Result_Dialog(result,mode)
        result_dialog.exec_()

    def Multi_Aspect(self, comb_cascade, cat_num=3, debug_display=False):

        beginTime = time.time()
        cascade_num = comb_cascade.cascade_num
        node_num = comb_cascade.node_num
        beta = cascade_num/cat_num

        comb_cascade.init_cat_labels()

        # 初始 label 隔1个调正确
        # start = 0
        # while start < cascade_num:
        #     comb_cascade.labels[start] = int(start/beta)
        #     start += 2

        # beta ratio 初始 label 隔1个调正确
        start = 0
        while start < cascade_num:
            if start < beta[0]:
                comb_cascade.labels[start] = 0
            elif beta[0] <= start < beta[0] + beta[1]:
                comb_cascade.labels[start] = 1
            else:
                comb_cascade.labels[start] = 2
            start += 2

        piValue = np.zeros(cat_num)
        for cat in range(cat_num):
            piValue[cat] = np.sum(comb_cascade.labels == cat) / cascade_num
        print("initial piValue: ", piValue)

        # print("init with accuracy: %.2f %%" % (100 * comb_cascade.cal_labels_accuracy()))

        ground_truth_labels = np.ones([cascade_num])
        # # for i in range(int(cascade_num / 2)):
        # #     ground_truth_labels[i] = 0
        #
        # # for i in range(int(cascade_num)):
        # #     ground_truth_labels[i] = int(i/beta)
        #
        # ground_truth_labels[:beta[0]] = 0
        # ground_truth_labels[beta[0]:beta[0]+beta[1]] = 1
        # ground_truth_labels[beta[0]+beta[1]:beta[0]+beta[1]+beta[2]] = 2
        #
        # # comb_cascade.label_renew(ground_truth_labels)
        true_label_value = 0
        bi_begin_index = 0
        for bi in range(len(beta)):
            bi_end_index = bi_begin_index + beta[bi]
            ground_truth_labels[bi_begin_index:bi_end_index] = true_label_value
            bi_begin_index = bi_end_index
            true_label_value = true_label_value + 1

        sub_net_list = []
        for i in range(cat_num):  # 初始化cat_num个m_network
            tmp_net = nt.m_network(node_num)
            sub_net_list.append(tmp_net)
            tmp_net = None
        theta_dict = []  # 记录每个aspect的各节点(i)各父节点组合(j)的theta值
        for i in range(cat_num):
            tmp_dict = {}
            theta_dict.append(tmp_dict)
            tmp_dict = None
        cnt = 0
        while True:
            ite_begin_time = time.time()
            cnt += 1
            # first step: generate network
            # 1.1 generate network structure
            # clear all sub-graphs
            for i in range(cat_num):  # sub_net_list: 每个aspect的边
                sub_net_list[i].clear_graph()  # 清空，都置为0
                sub_net_list[i] = net_util.net_parent_set_reconstruct_5a(sub_net_list[i], comb_cascade, i, 0)
                # sub_net_list[i] = net_util.net_parent_set_reconstruct_aaai(sub_net_list[i], comb_cascade, i, 0)
                # sub_net_list[i] = net_util.aaai_construct(sub_net_list[i], comb_cascade, i, 0)
                print("graph %d has %d edges " % (i, sub_net_list[i].edge_num))
            # os.system("pause")

            # 1.2 update theta
            for i in range(cat_num):
                theta_dict[i].clear()
                theta_dict[i] = net_util.get_theta(theta_dict[i], comb_cascade, i, sub_net_list[i], display=0)
                # sub_net_list[cat].display_edges()
                print("finish calculating theta for graph %d" % i)
                # os.system("pause")

            # import json
            # jsObj = json.dumps(theta_dict, indent=4)  # indent参数是换行和缩进
            # fileObject = open('1.json', 'w')
            # fileObject.write(jsObj)
            # fileObject.close()  # 最终写入的json文件格式

            # second step: re-assign labels of cascades
            finish_label = True
            record_score = np.zeros(node_num)
            record_value_i = np.zeros(node_num)
            record_aspect = np.zeros(cat_num)

            for c in range(cascade_num):
                max_likelihood = -np.inf
                max_label = -1
                for cat in range(cat_num):
                    score = 1
                    for i in range(node_num):
                        parent_id_set = np.argwhere(sub_net_list[cat].graph[:, i] == 1).flatten()  # 父节点集合
                        parent_state = comb_cascade.cascade[c][parent_id_set.astype(int)]  # 从这条记录中取出父节点的状态
                        # 取出theta值
                        key = ''.join(str(int(s)) for s in parent_state)
                        # print('c = ' + str(c) + ', cat = ' + str(cat) + ', i = ' + str(i))
                        # if (c == 0) and (cat == 1) and (i == 0):
                        #     print('c = ' + str(c) + ', cat = ' + str(cat) + ', i = ' + str(i))
                        value = theta_dict[cat][i].get(key)
                        if comb_cascade.cascade[c][i] == 1:
                            value_i = value
                        else:
                            value_i = 1 - value
                        score *= value_i
                        record_value_i[i] = value_i
                        record_score[i] = score
                    record_aspect[cat] = score
                    if score > max_likelihood:
                        max_likelihood = score
                        max_label = cat
                if finish_label and max_label != comb_cascade.labels[c]:
                    finish_label = False
                comb_cascade.labels[c] = max_label

            if debug_display:
                ite_end_time = time.time()
                ite_time = ite_end_time - ite_begin_time

                print("iter %d times" % cnt)
                print("curIteTime cost: ", ite_time * 1000)
                # print(" with accuracy: %.2f %%" % (100 * comb_cascade.cal_labels_accuracy()))

                piValue = np.zeros(cat_num)
                for cat in range(cat_num):
                    piValue[cat] = np.sum(comb_cascade.labels == cat) / cascade_num
                print(piValue)

                print(comb_cascade.labels)
                print("\n\n")
            else:
                print("iter %d times" % cnt)

            midTime = time.time()
            print("curTime cost: ", (midTime - beginTime) * 1000)

            # if cnt < 15:
            #     finish_label = False

            if finish_label:
                endTime = time.time()
                print("time cost: ", (endTime - beginTime) * 1000)
                print("\n\n\nProcess finished! \n\n\n")
                break
        return sub_net_list

    def LIDO(self, incomplete_result):

        small_times = 4  # 每个图的采样次数
        big_times = 6  # 图的个数
        sample_choice = 0  # 初始化采样选项： sample_choice = 0 统计得到先验；  =1 初始化为0.5
        equation_flag_s = False  # False：迭代方式  True：方程 fsolve
        equation_flag_lambda = False  # 实验现象反映 迭代的方式比方程还快一些
        stop_threshold = 10  # 求边权的停止条件。差值绝对值之和小于该阈值。
        initial_epsilon = 0.001  # 梯度下降学习速率
        construct_choice = 0  # 0:tends   1:twind
        epsilon_change = False

        # 初始采样
        results_list, prior_prob, temp_results_list = init_sample(incomplete_result, small_times, big_times,
                                                                  sample_choice)

        one_cnt_list = np.zeros(big_times)
        for i in range(big_times):
            result_i = results_list[i]
            one_cnt = np.sum(result_i[np.where(incomplete_result == -1)])
            one_cnt_list[i] = one_cnt

        print('initial sample one_cnt list=', one_cnt_list)
        print("average one_cnt =", np.mean(one_cnt_list))

        it_cnt = 1
        pre_network_stru = np.zeros(incomplete_result.shape)

        begin_all = time.time()
        while True:
            it_begin = time.time()
            print("第%d轮迭代" % it_cnt)

            # 构图
            if construct_choice == 0:
                network_list = construct_network_icde(results_list, big_times)
            elif construct_choice == 1:
                network_list = construct_network_twind(results_list, big_times)
            print("construct network suc.")


            # 合图
            comb_network = combine_network(network_list)
            print("combine network suc.")

            change_num = np.sum(abs(comb_network - pre_network_stru))
            print("与上一轮发生变化的边数：", change_num)
            if change_num == 0:
                break

            pre_network_stru = comb_network.copy()

            if it_cnt == 1:
                print("TENDS time cost:", time.time() - begin_all)

            # 初始化p
            p_matrix = init_p(comb_network)
            print("init p suc.")
            print("initial p sum =", np.sum(p_matrix))

            # modified_p = modify_p(ground_truth_network, p_matrix)
            # modified_init_mae = cal_mae(ground_truth_network, p, modified_p)
            # modified_init_mse = cal_mse(p, modified_p)
            # modified_init_mae_v2 = cal_mae_v2(ground_truth_network, p, modified_p)
            # modified_init_mse_v2 = cal_mse_v2(ground_truth_network, p, modified_p)
            # print("modified_init_MAE=%f, modified_init_MSE=%f, modified_init_MAE_v2=%f, modified_init_MSE_v2=%f" % (
            # modified_init_mae, modified_init_mse, modified_init_mae_v2, modified_init_mse_v2))

            # 调试用
            # plt.figure(0)
            # draw_p = p_matrix[np.where(comb_network==1)]
            # plt.hist(draw_p,bins=100)
            # plt.show()

            print("updating p with gradient...")
            grd_begin = time.time()
            grd_it_cnt = 1
            while True:
                inner_begin = time.time()
                s_matrix = cal_s(p_matrix, incomplete_result, comb_network, prior_prob, equation_flag_s)
                print("calculate s suc.")

                lambda_matrix = cal_lambda(p_matrix, s_matrix, comb_network, incomplete_result, equation_flag_lambda)
                print("calculate lambda suc.")

                pre_p_matrix = p_matrix.copy()

                p_matrix = update_p(p_matrix, s_matrix, lambda_matrix, comb_network, incomplete_result, initial_epsilon,
                                    grd_it_cnt, epsilon_change)
                print("update p suc.")
                print("new p sum =", np.sum(p_matrix))


                # modified_p = modify_p(ground_truth_network, p_matrix)
                # modified_mae = cal_mae(ground_truth_network, p, modified_p)
                # modified_mse = cal_mse(p, modified_p)
                # modified_mae_v2 = cal_mae_v2(ground_truth_network, p, modified_p)
                # modified_mse_v2 = cal_mse_v2(ground_truth_network, p, modified_p)
                # print("modified_MAE=%f, modified_MSE=%f, modified_MAE_v2=%f, modified_MSE_v2=%f" % (
                # modified_mae, modified_mse, modified_mae_v2, modified_mse_v2))

                inner_end = time.time()
                print("grad %d iter suc. time cost: %.2f" % (grd_it_cnt, inner_end - inner_begin))

                grd_it_cnt += 1
                delta_p_matrix = np.sum(abs(p_matrix - pre_p_matrix))
                print("delta_p_matrix=", delta_p_matrix)
                print("0<1之间的数：", np.sum((p_matrix > 0) * (p_matrix < 1)))
                print("-------------------------")
                if delta_p_matrix < stop_threshold:
                    break

            grd_end = time.time()
            # mae = cal_mae(ground_truth_network, p, p_matrix)
            # mse = cal_mse(p, p_matrix)
            # mae_v2 = cal_mae_v2(ground_truth_network, p, p_matrix)
            # mse_v2 = cal_mse_v2(ground_truth_network, p, p_matrix)
            #
            # modified_p = modify_p(ground_truth_network, p_matrix)
            # modified_mae = cal_mae(ground_truth_network, p, modified_p)
            # modified_mse = cal_mse(p, modified_p)
            # modified_mae_v2 = cal_mae_v2(ground_truth_network, p, modified_p)
            # modified_mse_v2 = cal_mse_v2(ground_truth_network, p, modified_p)

            s_matrix = cal_s(p_matrix, incomplete_result, comb_network, prior_prob, equation_flag_s)  # 最新的s_matrix
            print("calculate s suc.")

            # big_times+=2    # 每轮迭代后合图数增加来弥补recall的下降

            results_list, temp_results_list = sample_data_s(s_matrix, incomplete_result, small_times, big_times)
            print("sample complete data adt s suc.")

            one_cnt_list = np.zeros(big_times)
            for i in range(big_times):
                result_i = results_list[i]
                one_cnt = np.sum(result_i[np.where(incomplete_result == -1)])
                one_cnt_list[i] = one_cnt

            print('new sample one_cnt list=', one_cnt_list)
            print("average one_cnt =", np.mean(one_cnt_list))

            it_end = time.time()

            print("第 %d 轮迭代结束，用时: %.5f 秒" % (it_cnt, it_end - it_begin))
            print("第 %d 轮迭代结束，总用时: %.5f 秒" % (it_cnt, it_end - begin_all))
            if it_cnt > 5:
                break

            it_cnt += 1

        end_all = time.time()
        print("算法停止，共迭代了%d轮，总共用时: %.5f 秒" % (it_cnt, end_all - begin_all))

        return pre_network_stru
    def PIND(self, prob_result):
        update_x_sum_threshold = 5
        update_p_sum_threshold = 5
        max_delta_x_threshold = 0.005
        max_delta_p_threshold = 0.005
        learning_rate_p = 0.001
        learning_rate_x = 0.005
        sample_times = 15
        epsilon_change = False
        ourter_delta_x_threshold = 0.001
        comb_k = 3
        x_max_iteration = 15
        p_max_iteration = 15
        outer_max_iteration = 6

        nodes_num = prob_result.shape[1]
        # prune
        prune_network = weighted_mi_prune(prob_result, prune_choice=1)

        # soft initialization
        x_coe = 1e-5
        p_coe = 1e-5
        print("soft initialization,x_coe=%f,p_coe=%f" % (x_coe, p_coe))

        x_matrix = np.random.rand(nodes_num, nodes_num) * x_coe
        x_matrix[np.where(prune_network == 1)] = 1


        p_matrix = np.random.rand(nodes_num, nodes_num)
        p_matrix[np.where(prune_network == 0)] *= p_coe

        prior_network = np.ones((nodes_num, nodes_num))
        # prior_network=prune_network.copy()

        it_cnt = 0
        pre_x = x_matrix.copy()
        while True:
            it_cnt += 1
            print("--------------------------------------------------------------")
            print("outer %d th iteration begin." % (it_cnt))
            outer_begin = time.time()

            # update p
            p_matrix = with_x_likelihood_update_p(p_matrix, prob_result, prior_network, x_matrix, learning_rate_p,
                                                  it_cnt, epsilon_change, update_p_sum_threshold, max_delta_p_threshold, p_max_iteration)
            p_end = time.time()
            print("update p done! time cost=%f" % (p_end - outer_begin))

            print("...........................")

            # update x
            x_matrix = with_x_likelihood_update_x_combine(p_matrix, prob_result, prior_network, x_matrix,
                                                          learning_rate_x, it_cnt, epsilon_change,
                                                          update_x_sum_threshold,
                                                          max_delta_x_threshold, x_max_iteration)

            max_delta_x = np.max(abs(pre_x - x_matrix))
            if max_delta_x < ourter_delta_x_threshold or it_cnt >= outer_max_iteration:
                print("algorithm done!")
                break

            pre_x = x_matrix.copy()
        return pre_x
    def read_records_and_graph(self,record_path):
        record_df = pd.read_csv(record_path, sep='\t', header=None)
        record_data = record_df.values  # 提取其中的array

        return record_data

    def DPM(self, record_states):
        est_matrix, cov = self.construct_network_hsic(record_states, sigma=20, permutation_times=1)
        p_matrix = self.net_diffusion_rate_m(record_states, est_matrix)
        pc_matrix = self.stimulate_prob(est_matrix, p_matrix, break_num=1000, save_path=None)
        A = self.cluster_dominant_sets_rd(pc_matrix)
        return A

    def cluster_dominant_sets_rd(self, eivec_matrix: np.ndarray, SIM_MODE="HOMOP"):
        node_num = eivec_matrix.shape[0]
        if SIM_MODE == "HOMOP":
            similarity_matrix = self.get_homop_matrix(eivec_matrix)  # get_homop_sim_matrix(eivec_matrix)
        elif SIM_MODE == "COSINE":
            similarity_matrix = get_cosine_sim_matrix(eivec_matrix)
        elif SIM_MODE == "MAN":
            similarity_matrix = get_man_sim_matrix(eivec_matrix)
        elif SIM_MODE == "EU":
            similarity_matrix, _ = get_eu_sim_matrix(eivec_matrix)
        else:
            assert 0 > 1
        np.fill_diagonal(similarity_matrix, 0)

        U = np.array(range(node_num))  # 所有未归类点
        clusters = []
        iter_count = 0

        while similarity_matrix.shape[0] > 2:
            x = self.get_dominant_sets_rd(similarity_matrix)

            index = []
            k_means = KMeans(n_clusters=2).fit(x.reshape(-1, 1))
            max_label = 0 if k_means.cluster_centers_[0] >= k_means.cluster_centers_[1] else 1
            for i in range(len(x)):
                if k_means.labels_[i] == max_label:
                    index.append(i)
            # index = np.where(x > 1.0e-12)[0]

            node_index = U[index]  # dominant sets的原始下标
            clusters.append(list(node_index))

            similarity_matrix = np.delete(similarity_matrix, index, axis=0)
            similarity_matrix = np.delete(similarity_matrix, index, axis=1)  # 删除归类的点
            U = np.delete(U, index)
            iter_count += 1
        print(f"Iter Count: {iter_count}")

        if similarity_matrix.shape[0] != 0:
            clusters.append(U)

        # 将结果映射为A
        A = np.zeros((node_num, len(clusters)), dtype=np.int)
        for c in range(0, len(clusters)):
            cluster = clusters[c]
            for node in cluster:
                A[node][c] = 1

        return A

    def get_dominant_sets_rd(self, A: np.ndarray, epsilon=1.0e-4):
        x = np.ones(A.shape[0]) / float(A.shape[0])
        x = x.reshape(A.shape[0], 1)

        delta = epsilon * 2
        while delta > epsilon:
            x_old = x.copy()
            x = x * A.dot(x)
            x = x / x_old.T.dot(A).dot(x_old)

            delta = norm(x - x_old)

        return x

    def get_homop_matrix(self, eivec_matrix: np.ndarray):
        node_num = eivec_matrix.shape[0]
        similarity_matrix = np.zeros((node_num, node_num))

        # 对矩阵预处理，避免负数
        min_value = np.min(eivec_matrix)
        if min_value < 0:
            eivec_matrix += -min_value

        for i in range(node_num):
            for j in range(node_num):
                vector_i = eivec_matrix[i]
                vector_j = eivec_matrix[j]
                similarity_matrix[i][j] = np.sum(
                    ((np.minimum(vector_i, vector_j) + 1e-6) / (np.maximum(vector_i, vector_j) + 1e-6))
                    * (np.abs(vector_i + vector_j) / np.sum(vector_i + vector_j)))
        return similarity_matrix

    def get_com_dist_matrix(self, node_dist_matrix: np.ndarray, A: np.ndarray, mode=3):
        node_num, com_num = A.shape
        com_dist_matrix = np.zeros((com_num, com_num))
        for com1 in range(com_num):
            for com2 in range(com_num):
                if com1 > com2:
                    com_dist_matrix[com1][com2] = com_dist_matrix[com2][com1]
                    continue
                elif com1 == com2:
                    com_dist_matrix[com1][com2] = np.inf  # 对角线距离置为无穷大，避免找距离最近团找到自己
                    continue
                com1_nodes = np.where(A[:, com1] != 0)[0]
                com2_nodes = np.where(A[:, com2] != 0)[0]
                tmp_dist_matrix = node_dist_matrix[com1_nodes][:, com2_nodes]
                if mode == "Single":  # Single Linkage
                    com_dist_matrix[com1][com2] = np.min(tmp_dist_matrix)
                elif mode == "Complete":
                    com_dist_matrix[com1][com2] = np.max(tmp_dist_matrix)
                else:
                    com_dist_matrix[com1][com2] = np.average(tmp_dist_matrix)
        return com_dist_matrix

    def generateData(self, network: np.ndarray, p_matrix: np.ndarray, infectRate=0, seed=None):
        node_num = network.shape[0]
        node_state = np.zeros(node_num, dtype=np.int)

        # 选取随机种子
        if infectRate != 0:
            seed_infected_node_num = infectRate * node_num
            while seed_infected_node_num > 0:
                selected_node = random.randint(0, node_num)
                if node_state[selected_node] == 0:
                    node_state[selected_node] = 1
                    seed_infected_node_num -= 1
        else:
            for s in seed:
                node_state[s] = 1

        # 模拟爆发
        break_flag = False
        new_infected_nodes = np.where(node_state == 1)[0].tolist()
        while not break_flag:
            # 感染邻居节点
            new_infected_neighbors = []
            for node in new_infected_nodes:
                neighbor_nodes = np.where(network[node] == 1)[0]
                for neighbor_node in neighbor_nodes:
                    if node_state[neighbor_node] == 0:
                        if random.random() < p_matrix[node][neighbor_node]:
                            node_state[neighbor_node] = 1
                            new_infected_neighbors.append(neighbor_node)
            if np.sum(new_infected_nodes) == 0:
                break_flag = True
            new_infected_nodes = new_infected_neighbors

        return node_state

    def stimulate_prob(self, network: np.ndarray, p_matrix: np.ndarray, break_num: int, save_path=None):
        if (save_path is not None) and os.path.exists(save_path):
            return np.loadtxt(save_path, delimiter=',', dtype=np.float)
        node_num = network.shape[0]
        # break_num = 1000
        pc_matrix = np.zeros((node_num, node_num))
        for i in range(node_num):
            # print(f"\t{i}/{node_num}")
            for j in range(break_num):
                pc_matrix[i] += self.generateData(network, p_matrix, seed=[i])
        pc_matrix /= break_num
        if save_path is not None:
            np.savetxt(save_path, pc_matrix, fmt='%f', delimiter=',')
        return pc_matrix

    def net_diffusion_rate_m(self, record_states, network_structure):
        # network diffusion rate estimation
        # 传播网络传播概率估计
        # 输入： record_states(np.array)-感染传播结果，network_structure(np.array)-网络结构
        # 输出： 每条边对应的感染概率

        record_num, node_num = record_states.shape
        f = np.zeros([record_num, node_num, node_num])  # f 对应论文中的phi
        p_matrix = np.random.random([node_num, node_num])  # 随机初始化传播概率
        max_err = 0.001  # 迭代终止条件
        iter_cnt = 0
        neg_cnt = np.zeros([node_num, node_num])  # 论文中的|S^-|

        # start pre-calculation   # 预先对爆发结果进行统计，得到之后EM迭代需要用到的中间变量
        node_positive_record_mask = np.zeros(
            [node_num, node_num, record_num])  # node_positive_record_mask[i,j,L] = 1，表示在第L条爆发记录中，节点i,j都处于感染状态
        for i in range(node_num):
            for j in range(node_num):
                if network_structure[i, j] == 0:
                    continue

                for index in range(record_num):
                    if record_states[index, i] == 1 and record_states[index, j] == 1:
                        node_positive_record_mask[i, j, index] = 1
                    elif record_states[index, i] != record_states[index, j]:
                        neg_cnt[i, j] += 1
        # end pre-calculation

        while True:
            iter_cnt += 1

            # first: update f
            tmp_1_p = 1 - p_matrix
            for idx in range(record_num):
                graph_cas = network_structure * record_states[idx].reshape([node_num, 1])
                tmp = tmp_1_p * graph_cas
                tmp[tmp == 0] = 1
                sub = 1 - np.prod(tmp, axis=0)
                sub[sub == 0] = np.inf
                f[idx, :, :] = np.copy(p_matrix / sub)
                f[idx, :, :] = f[idx, :, :] * record_states[idx]
                f[idx, :, :] = f[idx, :, :] * record_states[idx].reshape([node_num, 1])

            # second: update p
            finish_label = True
            for i in range(node_num):
                for j in range(node_num):
                    if network_structure[i, j] != 1:
                        assign_value = 0
                    else:
                        pos_sum = np.sum(f[:, i, j] * node_positive_record_mask[i, j])
                        if pos_sum + neg_cnt[i, j] != 0:
                            assign_value = pos_sum / (pos_sum + neg_cnt[i, j])
                        else:
                            assign_value = 0

                    if finish_label and np.abs(assign_value - p_matrix[i, j]) > max_err:
                        finish_label = False
                    p_matrix[i, j] = assign_value
                    if assign_value > 1:
                        print("assign value = %f" % assign_value)
                        os.system("pause")

            # third: judge when to stop
            if finish_label:
                # print("\t\tfinish EM process with %d iterations" % iter_cnt)
                break
            # else:
            # print("\t\titerate %d times;" % iter_cnt)

        return p_matrix
    def construct_network_hsic(self, record_states, sigma=20, permutation_times=1):

        pruning_matrix, cov = self.cal_pruning_matrix(record_states, sigma=sigma)
        return pruning_matrix, cov

    def cal_pruning_matrix(self, data, sigma):
        cov = self.cal_hsic_matrix(data, sigma=sigma)
        cov2 = copy.deepcopy(cov)
        min_v = np.min(cov2)
        for i in range(cov2.shape[0]):
            cov2[i, i] = min_v
        cov2 = np.reshape(cov2, (-1, 1))
        km = KMeans(2)
        km.fit(cov2)
        pruning_matrix = np.reshape(km.labels_, (cov.shape[0], cov.shape[1]))
        # pruning_matrix = np.reshape(k_means(np.reshape(cov2, (-1, 1))), (cov.shape[0], cov.shape[1]))
        return pruning_matrix, cov

    def cal_hsic_matrix(self, all_data, sigma):
        kx_list = []
        for i in range(all_data.shape[1]):
            # print(i)
            kx = self.cal_k_matrix(all_data[:, i], sigma)
            kx_list.append(kx)
        dimension = len(kx_list)
        hsic_matrix = np.zeros((dimension, dimension))
        # with ThreadPoolExecutor(max_workers=5) as t:
        #     all_task = [t.submit(spider, page) for page in range(1, 5)]
        #     wait(all_task, return_when=FIRST_COMPLETED)
        #     print('finished')
        #     print(wait(all_task, timeout=2.5))
        # for i in range(dimension):
        #     for j in range(dimension):
        #         hsic_matrix[i][j] = cal_hsic(kx_list[i], kx_list[j])
        with ThreadPoolExecutor(max_workers=5) as tp:
            all_task = []
            for i in range(dimension):
                for j in range(dimension):
                    all_task.append(tp.submit(self.update_hsic_matrix, hsic_matrix, i, j, kx_list[i], kx_list[j]))
            wait(all_task)
        return hsic_matrix

    def cal_k_matrix(self, x, sigma):
        """
        :param x: n*m的数组，n为记录条数，m为数据维度
        :param sigma:用于计算矩阵的常数
        :return:K矩阵
        """
        # data_size = x.shape[0]
        # k_matrix = np.zeros((data_size, data_size))
        # for i in range(data_size):
        #     for j in range(data_size):
        #         k_matrix[i, j] = np.exp(-np.linalg.norm(x[i]-x[j]) ** 2 / sigma ** 2)

        if len(x.shape) == 1:
            x = np.reshape(x, (x.shape[0], 1))
        x1 = np.dot(x, x.T)
        xd = np.expand_dims(x1.diagonal(), 0)
        i = np.ones((1, xd.shape[1]))
        x2 = np.dot(xd.T, i)
        x3 = np.dot(i.T, xd)
        Kx = x2 + x3 - 2 * x1
        Kx = np.exp(- Kx / sigma ** 2)
        return Kx
    def update_hsic_matrix(self, hsic_matrix, i, j, kx, ky):
        hsic_matrix[i, j] = self.cal_hsic(kx, ky)

    def cal_hsic(self, kx, ky):
        n = kx.shape[0]
        # j = np.identity(n)
        # j -= 1/n
        # temp = np.dot(kx, j)
        # temp = np.dot(temp, ky)
        # temp = np.dot(temp, j)
        # return np.trace(temp)/(n-1)**2
        kxy = np.dot(kx, ky)
        h = np.trace(kxy) / n ** 2 + np.mean(kx) * np.mean(ky) - 2 * np.mean(kxy) / n
        return h * n ** 2 / (n - 1) ** 2
    def IMI_prune(self,record_states):
        results_num, nodes_num = record_states.shape
        print("\nresults_num = ", results_num)
        IMI = np.zeros((nodes_num, nodes_num))

        for j in range(nodes_num):
            for k in range(nodes_num):
                if j >= k:
                    continue
                state_mat = np.zeros((2, 2))
                for result_index in range(results_num):
                    state_mat[int(record_states[result_index, j]), int(record_states[result_index, k])] += 1

                epsilon = 1e-5
                M00 = state_mat[0, 0] / results_num * math.log(
                    state_mat[0, 0] * results_num / (state_mat[0, 0] + state_mat[0, 1]) / (
                            state_mat[0, 0] + state_mat[1, 0]) + epsilon, 2)
                M01 = state_mat[0, 1] / results_num * math.log(
                    state_mat[0, 1] * results_num / (state_mat[0, 0] + state_mat[0, 1]) / (
                            state_mat[0, 1] + state_mat[1, 1]) + epsilon, 2)
                M10 = state_mat[1, 0] / results_num * math.log(
                    state_mat[1, 0] * results_num / (state_mat[1, 0] + state_mat[1, 1]) / (
                            state_mat[0, 0] + state_mat[1, 0]) + epsilon, 2)
                M11 = state_mat[1, 1] / results_num * math.log(
                    state_mat[1, 1] * results_num / (state_mat[1, 0] + state_mat[1, 1]) / (
                            state_mat[0, 1] + state_mat[1, 1]) + epsilon, 2)

                IMI[j, k] = M00 + M11 - abs(M10) - abs(M01)
                # IMI[j, k] = M00 + M11 +M10 + M01
                IMI[k, j] = IMI[j, k]

        # Kmeans 聚类
        IMI[np.where(IMI < 0)] = 0
        tmp_IMI = IMI.reshape((-1, 1))
        tmp_IMI = tmp_IMI[np.where(tmp_IMI > 0)].reshape((-1, 1))  # 在这里切的时候只考虑大于0的值（跟tends的java版本一致）
        # 只考虑正数的情况和一刀切，考虑0值的情况在beta=100(120),150的时候有所差别，其余无明显差别

        estimator = KMeans(n_clusters=2)
        estimator.fit(tmp_IMI)
        label_pred = estimator.labels_
        temp_0 = tmp_IMI[label_pred == 0]
        temp_1 = tmp_IMI[label_pred == 1]

        tau = min(np.max(temp_1), np.max(temp_0))
        prune_network = np.zeros((nodes_num, nodes_num))
        prune_network[np.where(IMI > tau)] = 1

        return prune_network


    def node_lidu_clicked_event(self):
        # 选择节点粒度
        self.lidu_type = "node"
        self.radioButton_multi_aspect.setEnabled(True)
        if self.radioButton_one_aspect.isChecked():
            # 取消不可选中
            self.radioButton_incomplete_data.setEnabled(True)
            self.radioButton_noise_data.setEnabled(True)

    def group_lidu_clicked_event(self):
        # 选择团体粒度
        self.lidu_type = "group"
        # 设置为不可选中
        self.radioButton_multi_aspect.setDisabled(True)
        self.radioButton_incomplete_data.setDisabled(True)
        self.radioButton_noise_data.setDisabled(True)

    def one_aspect_clicked_event(self):
        # 选择单模态
        self.aspect_type = "one"
        if self.radioButton_node_lidu.isChecked():
            self.radioButton_incomplete_data.setEnabled(True)
            self.radioButton_noise_data.setEnabled(True)

    def multi_aspect_clicked_event(self):
        # 选择多模态
        self.aspect_type = "multi"
        # 设置为不可选中
        self.radioButton_incomplete_data.setDisabled(True)
        self.radioButton_noise_data.setDisabled(True)

    def complete_data_clicked_event(self):
        # 选择完整数据
        self.data_type = "complete"

    def noise_data_clicked_event(self):
        # 选择噪声数据
        self.data_type = "noise"

    def incomplete_data_clicked_event(self):
        # 选择不完整数据
        self.data_type = "incomplete"

    def get_file_path(self):
        # 获取文件路径
        file_path, _ = QFileDialog.getOpenFileName(None, "请选择文件", "", "All Files (*)")
        self.lineEdit_file_address.setText(file_path)
        self.file_path = file_path



class Result_Dialog(QDialog):
    # 展示推断结果的对话框
    def __init__(self,result,mode):
        super().__init__()
        self.result = result
        self.result_str = ""
        self.mode = mode
        self.init_Ui(self.result)


    def init_Ui(self,result):
        # 设置dialog窗口标题
        self.setWindowTitle("传播网络重构结果")
        # 设置界面尺寸大小
        self.resize(500, 450)
        self.textBrowser_result = QtWidgets.QTextBrowser(self)
        self.textBrowser_result.setGeometry(QtCore.QRect(10, 10, 481, 361))
        self.textBrowser_result.setObjectName("textBrowser_result")

        self.pushButton_exportResult = QtWidgets.QPushButton(self)
        self.pushButton_exportResult.setGeometry(QtCore.QRect(70, 390, 122, 32))
        self.pushButton_exportResult.setObjectName("pushButton_exportResult")
        self.pushButton_exportResult.setText("导出重构结果")

        self.pushButton_close = QtWidgets.QPushButton(self)
        self.pushButton_close.setGeometry(QtCore.QRect(300, 390, 122, 32))
        self.pushButton_close.setObjectName("pushButton_close")
        self.pushButton_close.setText("关闭")


        self.display_result()
        self.pushButton_exportResult.clicked.connect(self.exportResult_clicked_event)
        self.pushButton_close.clicked.connect(self.close_clicked_event)


    def exportResult_clicked_event(self):
        file_save_path = os.getcwd()
        current_datetime = datetime.datetime.now()
        file_name = current_datetime.strftime("%Y-%m-%d %H_%M_%S")
        file_save_path = file_save_path + "/result_" + file_name + ".txt"
        result_file = open(file_save_path,"w")
        result_file.write(self.result_str)
        result_file.close()

        self.textBrowser_result.append("重构结果已导出到:\n"+". /result_" + file_name + ". txt")
        self.textBrowser_result.moveCursor(self.textBrowser_result.textCursor().End)


    def close_clicked_event(self):
        self.close()

    def display_result(self):
        if self.mode == 4:
            # 多模态推断结果，result是一个网络列表
            cat_num = len(self.result)
            for i in range(cat_num):
                node_num = self.result[i].shape[0]
                self.result_str = "推断出的第" + str(i+1) + "个异质网络：\n"
                self.result_str = self.result_str + "(父节点ID,  子节点ID)\n"
                for j in range(node_num):
                    for k in range(node_num):
                        if self.result[j][k] == 1:
                            self.result_str = self.result_str + str(j) + ",  " + str(k) + "\n"


        elif self.mode == 3:
            # 同质团推断结果，result每行是一个团
            self.result_str = "(节点团编号：节点ID，节点ID，...。)\n"
            group_num = self.result.shape[1]
            node_num = self.result.shape[0]
            for i in range(group_num):
                self.result_str = self.result_str + str(i + 1) + ": "
                for j in range(node_num):
                    if self.result[i][j] == 1:
                        self.result_str = self.result_str + str(j) + ",  "
                self.result_str = self.result_str + "。\n\n"


        else :
            # result是一个numpy矩阵，结果是完整、噪音、确实数据网络
            node_number = self.result.shape[0]
            self.result_str = "(父节点ID,  子节点ID)\n"
            for i in range(node_number):
                for j in range(node_number):
                    if self.result[i][j] == 1:
                        self.result_str = self.result_str + str(i) + ",  " + str(j) + "\n"
        self.textBrowser_result.setText(self.result_str)







if __name__ == '__main__':
    # 创建QApplication类的实例
    app = QApplication(sys.argv)
    # 创建一个主窗口
    mainWindow = QMainWindow()
    # 创建Ui_MainWindow的实例
    ui = Ui_MainWindow()
    # 调用setupUi在指定窗口(主窗口)中添加控件
    ui.setupUi(mainWindow)
    # 显示窗口
    mainWindow.show()
    # 进入程序的主循环，并通过exit函数确保主循环安全结束
    sys.exit(app.exec_())